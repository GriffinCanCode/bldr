module infrastructure.analysis.detection.generator;

import std.stdio;
import std.string;
import std.conv;
import std.algorithm;
import std.array;
import std.path;
import infrastructure.config.schema.schema;
import infrastructure.analysis.detection.detector;
import infrastructure.analysis.detection.templates;
import infrastructure.analysis.manifests;

/// Enhanced template generator using manifest data
class EnhancedTemplateGenerator
{
    private ProjectMetadata metadata;
    private ManifestInfo[TargetLanguage] manifestInfo;
    private TemplateGenerator baseGenerator;
    
    this(ProjectMetadata metadata, ManifestInfo[TargetLanguage] manifestInfo)
    {
        this.metadata = metadata;
        this.manifestInfo = manifestInfo;
        this.baseGenerator = new TemplateGenerator(metadata);
    }
    
    /// Generate Builderfile with manifest-enhanced targets
    string generateBuilderfile()
    {
        string content = "// Builderfile - Auto-generated by 'bldr init'\n";
        content ~= "// Project: " ~ metadata.projectName ~ "\n";
        content ~= "// Generated with ecosystem integration\n\n";
        
        if (metadata.languages.empty)
            return content ~ generateGenericTarget();
        
        // Generate enhanced targets for each language
        foreach (langInfo; metadata.languages)
        {
            if (langInfo.language in manifestInfo)
            {
                // Use manifest data for smarter generation
                content ~= generateTargetFromManifest(langInfo, manifestInfo[langInfo.language]);
            }
            else
            {
                // Fallback to base generation
                content ~= generateBasicTarget(langInfo);
            }
            content ~= "\n";
        }
        
        return content;
    }
    
    /// Generate Builderspace (delegates to base)
    string generateBuilderspace()
    {
        return baseGenerator.generateBuilderspace();
    }
    
    private string generateTargetFromManifest(LanguageInfo langInfo, ManifestInfo manifest)
    {
        string target = format("target(\"%s\") {\n", manifest.name);
        target ~= format("    type: %s;\n", manifest.suggestedType.to!string.toLower);
        target ~= format("    language: %s;\n", manifest.language.to!string.toLower);
        
        // Use manifest entry points if available
        if (!manifest.entryPoints.empty)
        {
            if (manifest.entryPoints.length == 1)
                target ~= format("    sources: [\"%s\"];\n", manifest.entryPoints[0]);
            else
                target ~= format("    sources: %s;\n", formatArray(manifest.entryPoints));
        }
        else if (!manifest.sources.empty)
        {
            target ~= format("    sources: %s;\n", formatArray(manifest.sources));
        }
        else
        {
            target ~= format("    sources: %s;\n", formatArray(langInfo.sourceFiles));
        }
        
        // Add framework-specific config
        if ("framework" in manifest.metadata)
        {
            target ~= generateFrameworkConfig(manifest.language, manifest.metadata["framework"]);
        }
        
        // Add dependency notes if present
        if (!manifest.dependencies.empty)
        {
            auto runtimeDeps = manifest.dependencies.filter!(d => d.type == DependencyType.Runtime).array;
            if (!runtimeDeps.empty && runtimeDeps.length <= 5)
            {
                target ~= "    \n    // Dependencies: " ~ 
                         runtimeDeps.map!(d => d.name).join(", ") ~ "\n";
            }
        }
        
        target ~= "}";
        return target;
    }
    
    private string generateFrameworkConfig(TargetLanguage lang, string framework)
    {
        final switch (lang)
        {
            case TargetLanguage.JavaScript:
            case TargetLanguage.TypeScript:
                return generateJSFrameworkConfig(framework);
            case TargetLanguage.Python:
                return generatePythonFrameworkConfig(framework);
            case TargetLanguage.Rust:
                return generateRustFrameworkConfig(framework);
            case TargetLanguage.Go:
                return generateGoFrameworkConfig(framework);
            case TargetLanguage.PHP:
                return generatePHPFrameworkConfig(framework);
            case TargetLanguage.D:
            case TargetLanguage.Java:
            case TargetLanguage.Kotlin:
            case TargetLanguage.Scala:
            case TargetLanguage.C:
            case TargetLanguage.Cpp:
            case TargetLanguage.Ruby:
            case TargetLanguage.Perl:
            case TargetLanguage.Elixir:
            case TargetLanguage.Swift:
            case TargetLanguage.CSharp:
            case TargetLanguage.FSharp:
            case TargetLanguage.Zig:
            case TargetLanguage.Nim:
            case TargetLanguage.Lua:
            case TargetLanguage.R:
            case TargetLanguage.CSS:
            case TargetLanguage.Protobuf:
            case TargetLanguage.OCaml:
            case TargetLanguage.Haskell:
            case TargetLanguage.Elm:
            case TargetLanguage.Generic:
                return "";
        }
    }
    
    private string generateJSFrameworkConfig(string framework)
    {
        if (framework.canFind("react") || framework.canFind("vue") || framework.canFind("angular"))
        {
            string config = "    \n    config: {\n";
            config ~= "        \"mode\": \"bundle\",\n";
            config ~= "        \"bundler\": \"esbuild\",\n";
            config ~= "        \"platform\": \"browser\"\n";
            config ~= "    };\n";
            return config;
        }
        return "";
    }
    
    private string generatePythonFrameworkConfig(string framework)
    {
        if (framework == "django" || framework == "flask" || framework == "fastapi")
        {
            string config = "    \n    config: {\n";
            config ~= "        \"virtualenv\": true,\n";
            config ~= "        \"requirements\": \"requirements.txt\"\n";
            config ~= "    };\n";
            return config;
        }
        return "";
    }
    
    private string generateRustFrameworkConfig(string framework)
    {
        if (!framework.empty)
        {
            string config = "    \n    config: {\n";
            config ~= "        \"mode\": \"compile\",\n";
            config ~= "        \"edition\": \"2021\"\n";
            config ~= "    };\n";
            return config;
        }
        return "";
    }
    
    private string generateGoFrameworkConfig(string framework)
    {
        if (!framework.empty)
        {
            string config = "    \n    config: {\n";
            config ~= "        \"mode\": \"executable\",\n";
            config ~= "        \"modMode\": \"on\"\n";
            config ~= "    };\n";
            return config;
        }
        return "";
    }
    
    private string generatePHPFrameworkConfig(string framework)
    {
        return "";
    }
    
    private string generateBasicTarget(LanguageInfo langInfo)
    {
        // Delegate to base generator
        return baseGenerator.generateBuilderfile();
    }
    
    private string generateGenericTarget()
    {
        return baseGenerator.generateBuilderfile();
    }
    
    private string formatArray(string[] items)
    {
        if (items.empty)
            return "[]";
        
        if (items.length == 1)
            return format("[\"%s\"]", items[0]);
        
        return "[" ~ items.map!(i => "\"" ~ i ~ "\"").join(", ") ~ "]";
    }
}

