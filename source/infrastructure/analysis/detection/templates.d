module infrastructure.analysis.detection.templates;

import std.stdio;
import std.string;
import std.conv;
import std.algorithm;
import std.array;
import std.path;
import infrastructure.config.schema.schema;
import infrastructure.analysis.detection.detector;

/// Template generator for Builderfile and Builderspace
class TemplateGenerator
{
    private ProjectMetadata metadata;
    
    this(ProjectMetadata metadata)
    {
        this.metadata = metadata;
    }
    
    /// Generate Builderfile content
    string generateBuilderfile()
    {
        string content = "// Builderfile - Auto-generated by 'bldr init'\n";
        content ~= "// Project: " ~ metadata.projectName ~ "\n\n";
        
        if (metadata.languages.empty)
        {
            return content ~ generateGenericTarget();
        }
        
        // Generate targets for each detected language
        foreach (langInfo; metadata.languages)
        {
            content ~= generateTargetForLanguage(langInfo);
            content ~= "\n";
        }
        
        return content;
    }
    
    /// Generate Builderspace content
    string generateBuilderspace()
    {
        string content = "// Builderspace - Auto-generated by 'bldr init'\n";
        content ~= "// Workspace configuration for: " ~ metadata.projectName ~ "\n\n";
        
        content ~= format("workspace(\"%s\") {\n", metadata.projectName);
        content ~= "    cacheDir: \".builder-cache\";\n";
        content ~= "    outputDir: \"bin\";\n";
        content ~= "    parallel: true;\n";
        content ~= "    maxJobs: 4;\n";
        content ~= "    verbose: false;\n";
        content ~= "    incremental: true;\n";
        
        // Add language-specific environment variables
        if (!metadata.languages.empty)
        {
            string envVars = generateEnvVars();
            if (!envVars.empty)
            {
                content ~= "\n    env: {\n";
                content ~= envVars;
                content ~= "    };\n";
            }
        }
        
        content ~= "}\n";
        
        return content;
    }
    
    /// Generate target for a specific language
    private string generateTargetForLanguage(LanguageInfo langInfo)
    {
        final switch (langInfo.language)
        {
            case TargetLanguage.Python:
                return generatePythonTarget(langInfo);
            case TargetLanguage.JavaScript:
                return generateJavaScriptTarget(langInfo);
            case TargetLanguage.TypeScript:
                return generateTypeScriptTarget(langInfo);
            case TargetLanguage.Go:
                return generateGoTarget(langInfo);
            case TargetLanguage.Rust:
                return generateRustTarget(langInfo);
            case TargetLanguage.D:
                return generateDTarget(langInfo);
            case TargetLanguage.Java:
                return generateJavaTarget(langInfo);
            case TargetLanguage.Cpp:
                return generateCppTarget(langInfo);
            case TargetLanguage.C:
                return generateCTarget(langInfo);
            case TargetLanguage.Ruby:
                return generateRubyTarget(langInfo);
            case TargetLanguage.Perl:
                return generatePerlTarget(langInfo);
            case TargetLanguage.Elixir:
                return generateElixirTarget(langInfo);
            case TargetLanguage.PHP:
                return generatePHPTarget(langInfo);
            case TargetLanguage.Swift:
                return generateSwiftTarget(langInfo);
            case TargetLanguage.Kotlin:
                return generateKotlinTarget(langInfo);
            case TargetLanguage.CSharp:
                return generateCSharpTarget(langInfo);
            case TargetLanguage.Zig:
                return generateZigTarget(langInfo);
            case TargetLanguage.Scala:
                return generateScalaTarget(langInfo);
            case TargetLanguage.Nim:
                return generateNimTarget(langInfo);
            case TargetLanguage.Lua:
                return generateLuaTarget(langInfo);
            case TargetLanguage.R:
                return generateRTarget(langInfo);
            case TargetLanguage.FSharp:
                return generateFSharpTarget(langInfo);
            case TargetLanguage.CSS:
                return generateCSSTarget(langInfo);
            case TargetLanguage.Protobuf:
                return generateProtobufTarget(langInfo);
            case TargetLanguage.OCaml:
                return generateOCamlTarget(langInfo);
            case TargetLanguage.Haskell:
                return generateHaskellTarget(langInfo);
            case TargetLanguage.Elm:
                return generateElmTarget(langInfo);
            case TargetLanguage.Generic:
                return generateGenericTarget();
        }
    }
    
    /// Generate a unique target name for multi-language projects
    private string generateUniqueTargetName(string languageName, LanguageInfo info)
    {
        // For single-language projects, use the project name
        if (metadata.languages.length == 1)
        {
            return metadata.projectName;
        }
        
        string baseName = languageName; // Default to language name
        
        // For multi-language projects, try to infer a meaningful name from directory structure
        if (!info.sourceFiles.empty)
        {
            string firstFile = info.sourceFiles[0];
            string dir = dirName(firstFile);
            
            // If all files are in a specific subdirectory (not root), use that directory name
            if (dir != "." && !dir.empty)
            {
                string[] pathParts = dir.split("/");
                // Get the last non-empty part of the path
                foreach_reverse (part; pathParts)
                {
                    if (!part.empty && part != "." && part != "src" && part != "lib")
                    {
                        baseName = part;
                        break;
                    }
                }
            }
        }
        
        // Check if this name is already used by another language
        // Count how many languages would generate the same base name
        int nameCount = 0;
        int myIndex = 0;
        foreach (i, lang; metadata.languages)
        {
            string otherBaseName = getBaseName(lang);
            if (otherBaseName == baseName)
            {
                if (lang.language == info.language)
                    myIndex = nameCount;
                nameCount++;
            }
        }
        
        // If multiple languages share the same base name, append language name
        if (nameCount > 1)
        {
            return baseName ~ "-" ~ languageName;
        }
        
        return baseName;
    }
    
    /// Helper to get base name for a language (used for duplicate detection)
    private string getBaseName(LanguageInfo lang)
    {
        if (!lang.sourceFiles.empty)
        {
            string firstFile = lang.sourceFiles[0];
            string dir = dirName(firstFile);
            
            if (dir != "." && !dir.empty)
            {
                string[] pathParts = dir.split("/");
                foreach_reverse (part; pathParts)
                {
                    if (!part.empty && part != "." && part != "src" && part != "lib")
                    {
                        return part;
                    }
                }
            }
        }
        
        // Fallback to language name
        final switch (lang.language)
        {
            case TargetLanguage.Python: return "python";
            case TargetLanguage.JavaScript: return "javascript";
            case TargetLanguage.TypeScript: return "typescript";
            case TargetLanguage.Go: return "go";
            case TargetLanguage.Rust: return "rust";
            case TargetLanguage.D: return "d";
            case TargetLanguage.Java: return "java";
            case TargetLanguage.Cpp: return "cpp";
            case TargetLanguage.C: return "c";
            case TargetLanguage.Ruby: return "ruby";
            case TargetLanguage.Perl: return "perl";
            case TargetLanguage.Elixir: return "elixir";
            case TargetLanguage.PHP: return "php";
            case TargetLanguage.Swift: return "swift";
            case TargetLanguage.Kotlin: return "kotlin";
            case TargetLanguage.CSharp: return "csharp";
            case TargetLanguage.Zig: return "zig";
            case TargetLanguage.Scala: return "scala";
            case TargetLanguage.Nim: return "nim";
            case TargetLanguage.Lua: return "lua";
            case TargetLanguage.R: return "r";
            case TargetLanguage.FSharp: return "fsharp";
            case TargetLanguage.CSS: return "css";
            case TargetLanguage.Protobuf: return "protobuf";
            case TargetLanguage.OCaml: return "ocaml";
            case TargetLanguage.Haskell: return "haskell";
            case TargetLanguage.Elm: return "elm";
            case TargetLanguage.Generic: return "generic";
        }
    }
    
    /// Python target generation
    private string generatePythonTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.py");
        string targetName = generateUniqueTargetName("python", info);
        string targetType = hasMainFile(info.sourceFiles) ? "executable" : "library";
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= format("    type: %s;\n", targetType);
        target ~= "    language: python;\n";
        target ~= format("    sources: %s;\n", sources);
        
        // Add framework-specific config
        if (info.framework != ProjectFramework.None)
        {
            target ~= generatePythonFrameworkConfig(info.framework);
        }
        
        target ~= "}";
        return target;
    }
    
    /// JavaScript target generation
    private string generateJavaScriptTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.js");
        string targetName = generateUniqueTargetName("javascript", info);
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= "    type: executable;\n";
        target ~= "    language: javascript;\n";
        target ~= format("    sources: %s;\n", sources);
        
        // Add framework-specific config
        if (info.framework != ProjectFramework.None)
        {
            target ~= generateJavaScriptFrameworkConfig(info.framework);
        }
        
        target ~= "}";
        return target;
    }
    
    /// TypeScript target generation
    private string generateTypeScriptTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.ts");
        string targetName = generateUniqueTargetName("typescript", info);
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= "    type: executable;\n";
        target ~= "    language: typescript;\n";
        target ~= format("    sources: %s;\n", sources);
        
        // Add framework-specific config
        if (info.framework != ProjectFramework.None)
        {
            target ~= generateTypeScriptFrameworkConfig(info.framework);
        }
        else
        {
            target ~= "    \n";
            target ~= "    config: {\n";
            target ~= "        \"mode\": \"compile\",\n";
            target ~= "        \"outDir\": \"dist\",\n";
            target ~= "        \"module\": \"commonjs\",\n";
            target ~= "        \"target\": \"es2018\"\n";
            target ~= "    };\n";
        }
        
        target ~= "}";
        return target;
    }
    
    /// Go target generation
    private string generateGoTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.go");
        string targetName = generateUniqueTargetName("go", info);
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= "    type: executable;\n";
        target ~= "    language: go;\n";
        target ~= format("    sources: %s;\n", sources);
        target ~= "    \n";
        target ~= "    config: {\n";
        target ~= "        \"mode\": \"executable\",\n";
        target ~= "        \"trimpath\": true,\n";
        target ~= "        \"ldflags\": [\"-s\", \"-w\"],\n";
        target ~= "        \"modMode\": \"on\",\n";
        target ~= "        \"runFmt\": true,\n";
        target ~= "        \"runVet\": true\n";
        target ~= "    };\n";
        target ~= "}";
        
        return target;
    }
    
    /// Rust target generation
    private string generateRustTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.rs");
        string targetName = generateUniqueTargetName("rust", info);
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= "    type: executable;\n";
        target ~= "    language: rust;\n";
        target ~= format("    sources: %s;\n", sources);
        target ~= "    \n";
        target ~= "    config: {\n";
        target ~= "        \"mode\": \"compile\",\n";
        target ~= "        \"profile\": \"release\",\n";
        target ~= "        \"edition\": \"2021\",\n";
        target ~= "        \"optLevel\": \"3\"\n";
        target ~= "    };\n";
        target ~= "}";
        
        return target;
    }
    
    /// D target generation
    private string generateDTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.d");
        string targetName = generateUniqueTargetName("d", info);
        string targetType = hasMainFile(info.sourceFiles) ? "executable" : "library";
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= format("    type: %s;\n", targetType);
        target ~= "    language: d;\n";
        target ~= format("    sources: %s;\n", sources);
        target ~= "}";
        
        return target;
    }
    
    /// Java target generation
    private string generateJavaTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.java");
        string targetName = generateUniqueTargetName("java", info);
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= "    type: executable;\n";
        target ~= "    language: java;\n";
        target ~= format("    sources: %s;\n", sources);
        target ~= "}";
        
        return target;
    }
    
    /// C++ target generation
    private string generateCppTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.cpp");
        string targetName = generateUniqueTargetName("cpp", info);
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= "    type: executable;\n";
        target ~= "    language: cpp;\n";
        target ~= format("    sources: %s;\n", sources);
        target ~= "    flags: [\"-std=c++17\", \"-O2\"];\n";
        target ~= "}";
        
        return target;
    }
    
    /// C target generation
    private string generateCTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.c");
        string targetName = generateUniqueTargetName("c", info);
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= "    type: executable;\n";
        target ~= "    language: c;\n";
        target ~= format("    sources: %s;\n", sources);
        target ~= "    flags: [\"-std=c11\", \"-O2\"];\n";
        target ~= "}";
        
        return target;
    }
    
    /// Ruby target generation
    private string generateRubyTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.rb");
        string targetName = generateUniqueTargetName("ruby", info);
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= "    type: executable;\n";
        target ~= "    language: ruby;\n";
        target ~= format("    sources: %s;\n", sources);
        target ~= "}";
        
        return target;
    }
    
    /// Perl target generation
    private string generatePerlTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.pl");
        string targetName = generateUniqueTargetName("perl", info);
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= "    type: executable;\n";
        target ~= "    language: perl;\n";
        target ~= format("    sources: %s;\n", sources);
        target ~= "}";
        
        return target;
    }
    
    /// Elixir target generation
    private string generateElixirTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.ex");
        string targetName = generateUniqueTargetName("elixir", info);
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= "    type: executable;\n";
        target ~= "    language: elixir;\n";
        target ~= format("    sources: %s;\n", sources);
        target ~= "}";
        
        return target;
    }
    
    /// PHP target generation
    private string generatePHPTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.php");
        string targetName = generateUniqueTargetName("php", info);
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= "    type: executable;\n";
        target ~= "    language: php;\n";
        target ~= format("    sources: %s;\n", sources);
        target ~= "}";
        
        return target;
    }
    
    /// Swift target generation
    private string generateSwiftTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.swift");
        string targetName = generateUniqueTargetName("swift", info);
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= "    type: executable;\n";
        target ~= "    language: swift;\n";
        target ~= format("    sources: %s;\n", sources);
        target ~= "}";
        
        return target;
    }
    
    /// Kotlin target generation
    private string generateKotlinTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.kt");
        string targetName = generateUniqueTargetName("kotlin", info);
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= "    type: executable;\n";
        target ~= "    language: kotlin;\n";
        target ~= format("    sources: %s;\n", sources);
        target ~= "}";
        
        return target;
    }
    
    /// C# target generation
    private string generateCSharpTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.cs");
        string targetName = generateUniqueTargetName("csharp", info);
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= "    type: executable;\n";
        target ~= "    language: csharp;\n";
        target ~= format("    sources: %s;\n", sources);
        target ~= "}";
        
        return target;
    }
    
    /// Zig target generation
    private string generateZigTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.zig");
        string targetName = generateUniqueTargetName("zig", info);
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= "    type: executable;\n";
        target ~= "    language: zig;\n";
        target ~= format("    sources: %s;\n", sources);
        target ~= "}";
        
        return target;
    }
    
    /// Scala target generation
    private string generateScalaTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.scala");
        string targetName = generateUniqueTargetName("scala", info);
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= "    type: executable;\n";
        target ~= "    language: scala;\n";
        target ~= format("    sources: %s;\n", sources);
        target ~= "}";
        
        return target;
    }
    
    /// Nim target generation
    private string generateNimTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.nim");
        string targetName = generateUniqueTargetName("nim", info);
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= "    type: executable;\n";
        target ~= "    language: nim;\n";
        target ~= format("    sources: %s;\n", sources);
        target ~= "}";
        
        return target;
    }
    
    /// Lua target generation
    private string generateLuaTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.lua");
        string targetName = generateUniqueTargetName("lua", info);
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= "    type: executable;\n";
        target ~= "    language: lua;\n";
        target ~= format("    sources: %s;\n", sources);
        target ~= "}";
        
        return target;
    }
    
    /// R target generation
    private string generateRTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.R");
        string targetName = generateUniqueTargetName("r", info);
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= "    type: executable;\n";
        target ~= "    language: r;\n";
        target ~= format("    sources: %s;\n", sources);
        target ~= "}";
        
        return target;
    }
    
    /// F# target generation
    private string generateFSharpTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.fs");
        string targetName = generateUniqueTargetName("fsharp", info);
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= "    type: executable;\n";
        target ~= "    language: fsharp;\n";
        target ~= format("    sources: %s;\n", sources);
        target ~= "}";
        
        return target;
    }
    
    /// CSS target generation
    private string generateCSSTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.css");
        string targetName = generateUniqueTargetName("css", info);
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= "    type: custom;\n";
        target ~= "    language: css;\n";
        target ~= format("    sources: %s;\n", sources);
        target ~= "}";
        
        return target;
    }
    
    /// Protobuf target generation
    private string generateProtobufTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.proto");
        string targetName = generateUniqueTargetName("protobuf", info);
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= "    type: library;\n";
        target ~= "    language: protobuf;\n";
        target ~= format("    sources: %s;\n", sources);
        target ~= "}";
        
        return target;
    }
    
    /// OCaml target generation
    private string generateOCamlTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.ml");
        string targetName = generateUniqueTargetName("ocaml", info);
        string targetType = hasMainFile(info.sourceFiles) ? "executable" : "library";
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= format("    type: %s;\n", targetType);
        target ~= "    language: ocaml;\n";
        target ~= format("    sources: %s;\n", sources);
        target ~= "}";
        
        return target;
    }
    
    /// Haskell target generation
    private string generateHaskellTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.hs");
        string targetName = generateUniqueTargetName("haskell", info);
        string targetType = hasMainFile(info.sourceFiles) ? "executable" : "library";
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= format("    type: %s;\n", targetType);
        target ~= "    language: haskell;\n";
        target ~= format("    sources: %s;\n", sources);
        target ~= "}";
        
        return target;
    }
    
    /// Generate Elm target
    private string generateElmTarget(LanguageInfo info)
    {
        string sources = generateSourcesArray(info.sourceFiles, "*.elm");
        string targetName = generateUniqueTargetName("elm", info);
        string targetType = hasMainFile(info.sourceFiles) ? "executable" : "library";
        
        string target = format("target(\"%s\") {\n", targetName);
        target ~= format("    type: %s;\n", targetType);
        target ~= "    language: elm;\n";
        target ~= format("    sources: %s;\n", sources);
        
        // Add Elm-specific configuration
        target ~= "\n    elmConfig: {\n";
        target ~= "        optimize: false;\n";
        target ~= "        debug: true;\n";
        target ~= "        outputTarget: \"javascript\";\n";
        target ~= "    };\n";
        target ~= "}";
        
        return target;
    }
    
    /// Generic target generation (fallback)
    private string generateGenericTarget()
    {
        string target = format("target(\"%s\") {\n", metadata.projectName);
        target ~= "    type: executable;\n";
        target ~= "    sources: [\"main.*\"];\n";
        target ~= "}";
        
        return target;
    }
    
    /// Generate Python framework-specific config
    private string generatePythonFrameworkConfig(ProjectFramework framework)
    {
        string config = "    \n    config: {\n";
        
        final switch (framework)
        {
            case ProjectFramework.Django:
                config ~= "        \"mode\": \"module\",\n";
                config ~= "        \"virtualenv\": true,\n";
                config ~= "        \"requirements\": \"requirements.txt\"\n";
                break;
            case ProjectFramework.Flask:
            case ProjectFramework.FastAPI:
                config ~= "        \"mode\": \"script\",\n";
                config ~= "        \"virtualenv\": true,\n";
                config ~= "        \"requirements\": \"requirements.txt\"\n";
                break;
            case ProjectFramework.None:
            case ProjectFramework.React:
            case ProjectFramework.Vue:
            case ProjectFramework.Angular:
            case ProjectFramework.Svelte:
            case ProjectFramework.NextJS:
            case ProjectFramework.ViteReact:
            case ProjectFramework.ViteVue:
            case ProjectFramework.Express:
            case ProjectFramework.Gin:
            case ProjectFramework.Echo:
            case ProjectFramework.Fiber:
            case ProjectFramework.Actix:
            case ProjectFramework.Rocket:
            case ProjectFramework.Axum:
            case ProjectFramework.Rails:
            case ProjectFramework.Sinatra:
            case ProjectFramework.Phoenix:
            case ProjectFramework.PhoenixLiveView:
            case ProjectFramework.Laravel:
            case ProjectFramework.Symfony:
            case ProjectFramework.Spring:
            case ProjectFramework.Quarkus:
            case ProjectFramework.AspNetCore:
                return "";
        }
        
        config ~= "    };\n";
        return config;
    }
    
    /// Generate JavaScript framework-specific config
    private string generateJavaScriptFrameworkConfig(ProjectFramework framework)
    {
        final switch (framework)
        {
            case ProjectFramework.React:
            case ProjectFramework.ViteReact:
                return generateReactConfig(framework);
            case ProjectFramework.Vue:
            case ProjectFramework.ViteVue:
                return generateVueConfig(framework);
            case ProjectFramework.NextJS:
                return generateNextJSConfig();
            case ProjectFramework.None:
            case ProjectFramework.Angular:
            case ProjectFramework.Svelte:
            case ProjectFramework.Django:
            case ProjectFramework.Flask:
            case ProjectFramework.FastAPI:
            case ProjectFramework.Express:
            case ProjectFramework.Gin:
            case ProjectFramework.Echo:
            case ProjectFramework.Fiber:
            case ProjectFramework.Actix:
            case ProjectFramework.Rocket:
            case ProjectFramework.Axum:
            case ProjectFramework.Rails:
            case ProjectFramework.Sinatra:
            case ProjectFramework.Phoenix:
            case ProjectFramework.PhoenixLiveView:
            case ProjectFramework.Laravel:
            case ProjectFramework.Symfony:
            case ProjectFramework.Spring:
            case ProjectFramework.Quarkus:
            case ProjectFramework.AspNetCore:
                return "";
        }
    }
    
    /// Generate TypeScript framework-specific config
    private string generateTypeScriptFrameworkConfig(ProjectFramework framework)
    {
        return generateJavaScriptFrameworkConfig(framework);
    }
    
    /// Generate React-specific config
    private string generateReactConfig(ProjectFramework framework)
    {
        string config = "    \n    config: {\n";
        config ~= "        \"mode\": \"bundle\",\n";
        
        if (framework == ProjectFramework.ViteReact)
        {
            config ~= "        \"bundler\": \"vite\",\n";
        }
        else
        {
            config ~= "        \"bundler\": \"esbuild\",\n";
        }
        
        config ~= "        \"entry\": \"src/index.jsx\",\n";
        config ~= "        \"platform\": \"browser\",\n";
        config ~= "        \"jsx\": true,\n";
        config ~= "        \"minify\": true,\n";
        config ~= "        \"sourcemap\": true\n";
        config ~= "    };\n";
        
        return config;
    }
    
    /// Generate Vue-specific config
    private string generateVueConfig(ProjectFramework framework)
    {
        string config = "    \n    config: {\n";
        config ~= "        \"mode\": \"bundle\",\n";
        
        if (framework == ProjectFramework.ViteVue)
        {
            config ~= "        \"bundler\": \"vite\",\n";
        }
        else
        {
            config ~= "        \"bundler\": \"esbuild\",\n";
        }
        
        config ~= "        \"entry\": \"src/main.js\",\n";
        config ~= "        \"platform\": \"browser\",\n";
        config ~= "        \"minify\": true,\n";
        config ~= "        \"sourcemap\": true\n";
        config ~= "    };\n";
        
        return config;
    }
    
    /// Generate Next.js-specific config
    private string generateNextJSConfig()
    {
        string config = "    \n    config: {\n";
        config ~= "        \"mode\": \"nextjs\",\n";
        config ~= "        \"dev\": false\n";
        config ~= "    };\n";
        
        return config;
    }
    
    /// Generate sources array from file list
    private string generateSourcesArray(string[] files, string pattern)
    {
        // If we have a clear directory pattern, use globs
        if (files.length > 3)
        {
            // Find common directory
            if (files.length > 0)
            {
                string firstDir = dirName(files[0]);
                bool allSameDir = files.all!(f => dirName(f) == firstDir);
                
                if (allSameDir && firstDir != ".")
                {
                    return format("[\"%s/%s\"]", firstDir, pattern);
                }
            }
            
            // Use recursive glob
            return format("[\"%s\"]", pattern);
        }
        
        // List files explicitly for small projects
        if (files.empty)
            return format("[\"%s\"]", pattern);
        
        string[] quoted = files.map!(f => "\"" ~ f ~ "\"").array;
        return "[" ~ quoted.join(", ") ~ "]";
    }
    
    /// Check if any file has "main" in its name
    private bool hasMainFile(string[] files)
    {
        return files.any!(f => baseName(stripExtension(f)).toLower == "main");
    }
    
    /// Generate environment variables based on detected languages
    private string generateEnvVars()
    {
        string envVars = "";
        
        foreach (lang; metadata.languages)
        {
            final switch (lang.language)
            {
                case TargetLanguage.Python:
                    // envVars ~= "        \"PYTHONPATH\": \".\",\n";
                    break;
                case TargetLanguage.Go:
                    // envVars ~= "        \"GO111MODULE\": \"on\",\n";
                    break;
                case TargetLanguage.JavaScript:
                case TargetLanguage.TypeScript:
                case TargetLanguage.Rust:
                case TargetLanguage.D:
                case TargetLanguage.Java:
                case TargetLanguage.Cpp:
                case TargetLanguage.C:
                case TargetLanguage.Ruby:
                case TargetLanguage.Perl:
                case TargetLanguage.Elixir:
                case TargetLanguage.PHP:
                case TargetLanguage.Swift:
                case TargetLanguage.Kotlin:
                case TargetLanguage.CSharp:
                case TargetLanguage.FSharp:
                case TargetLanguage.Zig:
                case TargetLanguage.Scala:
                case TargetLanguage.Nim:
                case TargetLanguage.Lua:
                case TargetLanguage.R:
                case TargetLanguage.CSS:
                case TargetLanguage.Protobuf:
                case TargetLanguage.OCaml:
                case TargetLanguage.Haskell:
                case TargetLanguage.Elm:
                case TargetLanguage.Generic:
                    break;
            }
        }
        
        return envVars;
    }
}

